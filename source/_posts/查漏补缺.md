---
title: 查漏补缺
date: 2020-05-21 09:57:08
tags: [面试]
---

记录我的一些问题
<!-- more -->

## JS篇

### 1. 作用域

作用域是在运行代码中特定部分中的变量，函数和对象的可访问性。作用域决定了代码区块中变量和资源的可见性。作用域最大的作用就是隔离变量，不同作用域下的同名变量不会有冲突。

- 全局作用域：是指声明最外层的变量和末定义直接赋值的变量

- 函数作用域：是指声明在函数内部的变量

- 块级作用域：块级作用域可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问

### 2. 作用域链

在内部引用的变量一层一层的寻找对应的值，这种层层关系就是作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。

### 3. 执行上下文

JS属于解释型语言，javascript的执行分为：解释和执行

执行上下文是函数执行之前创建的。代码运行时产生对应的执行环境，在这个环境中所有的变量（变量提升，函数提升）会被先提出来，有赋值直接赋值，无赋值为undefine，代码从上而下执行，这就是执行上下文。

函数提升的优先级大于变量提升

#### 解释阶段

- 词法分析

- 语法分析

- 确定作用域

#### 执行阶段

- 创建执行上下文

- 执行函数代码

- 垃圾回收

### 4. 如何理解this

this永远指向最后调用它的那个对象

### 5. 什么是防抖和节流，请用代码实现

```javascript
/**
 * 防抖函数（非立即执行）
 * 多次操作只执行满足一定时间限制的条件操作
 * @param {function} func
 * @param {number} time
 */
const debounce = (func, time) => {
  let timeOver = null
  return () => {
    let self = this
    let args = arguments
    timeOver && clearTimeout(timeOver)
    timeOver = setTimeout(() => {
      func.apply(self, args)
    }, time)
  }
}

/* 防抖函数（立即执行） */
const debounce1 = (func, time) => {
  let timeOver = null
  return () => {
    let self = this
    let args = arguments
    timeOver && clearTimeout(timeOver)
    let tagTime = !timeOver
    timeOver = setTimeout(() => {
      timeOver = null
    }, time)
    if (tagTime) {
      func.apply(self, args)
    }
  }
}

/**
 * 节流
 * 一定时间内只能触发一次
 * @param {function} func
 * @param {number} time
 */
const throttle = (func, time) => {
  let timeOver = null
  return () => {
    let self = this
    let args = arguments
    if (timeOver) return false
    timeOver = setTimeout(() => {
      func.apply(self, args)
      timeOver = null
    }, time)
  }
}
```

### 6. call, apply, bind的区别，手动实现3个方法

```javascript
// call方法直接调用函数改变this,接受的参数call(this, arg0, arg1)
Function.prototype.myCall = function (thisC, ...args) {
  if (thisC === null || typeof thisC === undefined) {
    thisC = window
  }

  thisC.fn = this
  let res = thisC.fn(...args)
  delete thisC.fn
  return res
}

// apply方法直接调用函数改变this,接收参数apply(this, [arg0, arg1])
Function.prototype.myApply = function (thisC, args) {
  if (thisC === null || typeof thisC === undefined) {
    thisC = window
  }

  thisC.fn = this
  let res = thisC.fn(...args)
  delete thisC.fn
  return res
}

// bind方法返回一个绑定this的函数,接收参数为bind(this, arg0, arg1)
Function.prototype.myBind = function (thisC, ...args) {
  if (thisC === null || typeof thisC === undefined) {
    thisC = window
  }

  return function () {
    thisC.fn = this
    const res = thisC.fn(...args)
    delete thisC.fn
    return res
  }
}

Function.prototype.myBind = function (thisC, ...args) {
  if (thisC === null || typeof thisC === undefined) {
    thisC = window
  }

  let self = this

  return function () {
    return self.apply(thisC, args)
  }
}
```

### 7. new的过程

```javascript
let a = new Func(args)

new => let obj = {}
    => obj._proto_ = Func.prototype
    => let ret = Func.call(obj, args)
    => return typeof ret === "object" ? ret : obj
```

1. 创建空对象

2. 空对象的隐式原型指向构造函数的显式原型

3. 通过call改变对象的this指向

4. 如果无值和不是一个对象返回空对象,有值并且是个新对象返回该对象

### 8. 什么是原型，原型链？

原型就是继承实例上的属性的一个对象

原型可以通过_proto_属性访问原型的原型,这样一种自上而下的链式寻值关系就是原型链

### 9. 闭包的什么，原理是什么？

能读取其他函数内部变量的函数

内层函数的函数作用域未定义值在上层的函数作用域寻找到,并其执行上层函数时,该值的引用不为0,不会被JS垃圾回收机制回收,保证内层的函数调用的值一直存储在内存中

## CSS篇

### 1. css加载会造成阻塞吗？

css不会阻塞DOM树的解析，会阻塞DOM树的渲染，会阻塞JS的执行

优化方式：

1. 压缩CSS体积

2. 使用CDN资源

3. 合理使用缓存机制

4. 减少Http请求，多个CSS合并为一个

### 2. 有3个div，左右固定，如何实现中间自适应

### 3. flex布局有哪些属性

## Webpack篇

## Vue篇

## React篇

### 1. 什么是ref ？ref的作用是什么？

### 2. react中如何优化性能

1. React.lazy 和 Suspense

    `const A = React.lazy(() => import("component/A"))`

    组件首次渲染时，自动导入包含 A 组件的包

    ```jsx
    import React, { lazy, Suspense } from 'react'

    const LazyAdd = lazy(() => import("../LazyAdd"))

    const MyPage = () => {
      return <div>
        懒加载组件
        <Suspense fallback={<div>loading...</div>}>
          <LazyAdd />
        </Suspense>
      </div>
    }

    export default MyPage
    ```

    Suspense的fallback属性可以添加JSX,在加载过程中所展示的视图属性

    #### 优化点: 添加错误边界使模块加载失败变的可控

    ```jsx
    import React, { Component } from 'react'

    export default class ErrorBoundary extends Component {
      constructor (props) {
        super(props)
        this.state = {
          hasError: false
        }
      }

      static getDerivedStateFromError () {
        return { hasError: true }
      }

      componentDidCatch (error, errInfo) {
        console.log(error, errInfo)
      }

      render() {
        if (this.state.hasError) {
          return <h1>页面加载错误</h1>
        }

        return this.props.children
      }
    }
    ```

    它可以监听错误,并展示提示信息

    ```jsx
    render() {
      return <ErrorBoundary>
        <Suspense fallback={<div>loading...</div>}>
          <LazyAdd />
        </Suspense>
      </ErrorBoundary>
    }
    ```

2. shouldComponentUpdate

    只有update值改变时才会触发组件的视图层更新,可以减少频繁变动的值,对组件多次渲染带来的性能问题

    ```jsx
    shouldComponentUpdate (nextProps) {
      if (this.props.update !== nextProps.update) {
        return true
      }
      return false
    }
    ```

3. React.PureComponent

    这个组件更新渲染机制为浅比较,数组的直接push,和对象的直接新增都不会触发到组件的渲染机制

### 3. React多级传递

-  Context

-

## ES6篇

### 1. 箭头函数的this指向

箭头函数的this指向的是函数定义时的,不是执行时的this

箭头函数中没有this绑定,必须查找其作用域链来决定其值,如果箭头函数被非箭头函数包裹,那么它的this绑定的是最近一层的非箭头函数的this

### 2. 手写一个Promise

### 3. async,promise的区别

### 4. es6新加的数组方法

### 5. var,let,const的区别

### 6. JS的基本类型(包括新增)

## Typescript篇
